ANSIBLE_METADATA = {'metadata_version': '1.0',
                    'status': ['preview'],
                    'supported_by': 'community'}


DOCUMENTATION = '''
---
module: ipa_cert
author: John Morris (@zultron)
short_description: Manage FreeIPA certificates
description:
- Request and revoke certificates within IPA server
options:
  subject:
    description:
      - Subject (CN) of principal DN
      - Used to find cert and in cert requests
    required: true
  req:
    description:
      - Certificate request; used for C(state=present) to request a cert
      - As generated by C(openssl req)
      - Set CN same as C(subject) option
    required: false
  cacn:
    description:  IPA CA or sub-CA name for request or revoke
    required: false
    default: "ipa"
  principal:
    description:  Principal for this certificate (e.g. HTTP/test.example.com);
                  subject option should match CN; used in cert requests
    required: false
  serial_number:
    description: Cert serial number; used for C(state=absent) to revoke a cert
  revocation_reason:
    description: Reason for revoking cert
    required: false
    default: 0
    choices: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  state:
    description: State to ensure
    required: false
    default: present
    choices: ["present", "absent", "exact"]
  ipa_port:
    description: Port of IPA server
    required: false
    default: 443
  ipa_host:
    description: IP or hostname of IPA server
    required: false
    default: "ipa.example.com"
  ipa_user:
    description: Administrative account used on IPA server
    required: false
    default: "admin"
  ipa_pass:
    description: Password of administrative user
    required: true
  ipa_prot:
    description: Protocol used by IPA server
    required: false
    default: "https"
    choices: ["http", "https"]
  validate_certs:
    description:
    - This only applies if C(ipa_prot) is I(https).
    - If set to C(no), the SSL certificates will not be validated.
    - This should only set to C(no) used on personally controlled
      sites using self-signed certificates.
    required: false
    default: true
version_added: "2.3"
'''

EXAMPLES = '''
# Create 'vpn' ca
- ipa_c:
    name: vpn
    subject: CN=VPN Certificate Authority,O=EXAMPLE.COM
    state: present
    ipa_host: ipa.example.com
    ipa_user: admin
    ipa_pass: topsecret

# Remove 'vpn' ca
- ipa_ca:
    name: vpn
    state: absent
    ipa_host: ipa.example.com
    ipa_user: admin
    ipa_pass: topsecret
'''

RETURN = '''
ca:
  description: ca as returned by IPA API
  returned: always
  type: dict
'''

from ansible.module_utils.pycompat24 import get_exception
# from ansible.module_utils.ipa import IPAClient
from ipa import IPAClient, IPAObjectDiff

import re

class CertDiff(IPAObjectDiff):
    def enabled(self, action_type):
        if action_type == 'mod':
            # Existing certs are immutable
            return [{}, {}, {}]
        return super(CertDiff, self).enabled(action_type)

class CertClient(IPAClient):
    diff_class = CertDiff

    methods = dict(
        add = 'cert_request',
        rem = 'cert_revoke',
        find = 'cert_find',
        show = 'cert_show',
    )
    pos_args = [
        dict(name = 'serial_number', # cert-revoke
             spec = dict(type='str', required=False, aliases=['name'],
                         when=['rem'])),
        # serial_number?
        dict(name = 'req', # cert-request
             spec = dict(type='str', required=False, aliases=['name'],
                         when=['add'])),
    ]
    find_keys = ['subject', 'cacn']
    extra_find_args = dict(exactly=True)
    find_filter = lambda self,x: (x['status'] == 'VALID')
    rem_key = 'serial_number'
    add_or_mod_key = 'req'

    dn_to_cn_re = re.compile(r'CN=([^,]*),')
    def dn_to_cn(x):
        m = CertClient.dn_to_cn_re.match(x)
        return m.group(1) if m else None

    kw_args = dict(
        # Subject is required for searching
        subject = dict(
            type='str', required=True, when=[], filt=dn_to_cn),
        # "request" and "revoke" params
        cacn = dict(
            type='str', default='ipa'),
        # "request" params
        principal = dict(
            type='str', required=False, when=['add']),
        # "revoke" params
        revocation_reason = dict(
            type='int', required=False, choices=range(11), when=['rem']),
    )

    def add_or_mod(self, action_type, actions):
        item = dict( principal=self.param('subject') )
        if self.param('cacn') is not None:
            item['cacn'] = self.param('cacn')
        return self._post_json(
            method="cert_request",
            name=self.param('req'),
            item=item,
        )

    def rem(self):
        item = dict(
            revocation_reason = self.param('revocation_reason', '0'),
        )
        if self.param('cacn') is not None:
            item['cacn'] = self.param('cacn')
        rem_data = dict(
            method="cert_revoke",
            name=self.param('serial_number') or self.ipa_obj['serial_number'],
            item=item,
        )
        self.debug['rem_data'] = rem_data
        return self._post_json(**rem_data)

def main():
    client = CertClient()

    client.login()
    changed, cert = client.ensure()
    client.module.exit_json(changed=changed, cert=cert, debug=client.debug)
    # try:
    #     client.login()
    #     changed, ca = client.ensure()
    #     client.module.exit_json(changed=changed, ca=ca)
    # except Exception:
    #     e = get_exception()
    #     client.module.fail_json(msg=str(e), debug=client.debug)


if __name__ == '__main__':
    main()
